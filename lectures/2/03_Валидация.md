# Валидация запросов в FastAPI

## Введение

Любой API принимает данные извне → их нужно проверять.

Валидация защищает:
- от ошибок пользователей,
- от некорректных данных,
- от атак (например, слишком длинных строк или опасных данных).

В FastAPI валидация встроена:
- на уровне типов Python,
- через Pydantic-модели,
- с помощью кастомных правил.

## Базовая валидация через типы

FastAPI автоматически проверяет параметры по типам.

Path-параметры:
```
@app.get("/users/{user_id}")
def get_user(user_id: int):
    return {"user_id": user_id}
```
если передать abc вместо числа → ошибка 422.

Query-параметры с ограничениями
```
from fastapi import Query

@app.get("/items/")
def read_items(limit: int = Query(10, ge=1, le=100)):
    return {"limit": limit}
```
ge=1 → больше или равно 1;  
le=100 → меньше или равно 100;  
если передать limit=500, будет ошибка.

## Валидация тела запроса (Pydantic)

Ограничения на строки
```
from pydantic import BaseModel, constr

class User(BaseModel):
    username: constr(min_length=3, max_length=20)
```
имя пользователя должно быть от 3 до 20 символов;  
если не подходит → 422.

Проверка email
```
from pydantic import EmailStr

class Register(BaseModel):
    email: EmailStr
    password: str
```
EmailStr проверяет формат email.

Числовые ограничения
```
from pydantic import conint, confloat

class Product(BaseModel):
    price: confloat(gt=0)      # строго больше 0
    quantity: conint(ge=1, le=100)
```
gt — больше чем,  
ge — больше или равно,  
le — меньше или равно.

##  Кастомные валидаторы

Валидатор поля
```
from pydantic import validator

class User(BaseModel):
    username: str
    age: int

    @validator("age")
    def age_must_be_positive(cls, v):
        if v < 0:
            raise ValueError("Число должно быть положительным")
        return v
```

Валидатор для нескольких полей
```
class Booking(BaseModel):
    start_date: str
    end_date: str

    @validator("end_date")
    def check_dates(cls, v, values):
        if "start_date" in values and v < values["start_date"]:
            raise ValueError(
                f"""
                Начальная дата должна принимать одно из значений {values}.\n
                Конечная дата должна быть больше начальной
                """
            )
        return v
```

Корневой валидатор
```
from pydantic import root_validator

class Passwords(BaseModel):
    password: str
    confirm_password: str

    @root_validator
    def passwords_match(cls, values):
        if values["password"] != values["confirm_password"]:
            raise ValueError("Passwords do not match")
        return values
```

## Дополнительные возможности

Проверка URL:
```
from pydantic import AnyUrl

class Link(BaseModel):
    url: AnyUrl
```

Работа с регулярками:
```
class Phone(BaseModel):
    number: constr(regex=r"^\+7\d{10}$")
```

Использование Field для описания ограничений и документации:
```
from pydantic import Field

class User(BaseModel):
    name: str = Field(..., min_length=3, max_length=50, description="Имя пользователя")
```

## Использование в FastAPI

Пример: регистрация
```
@app.post("/register")
def register(data: Register):
    return {"email": data.email}
```
если email некорректный → вернётся 422 с JSON-описанием ошибки;  
документация (Swagger) сразу покажет все правила.

## Заключение

Валидация в FastAPI и Pydantic:
- простая (через типы и Query),
- декларативная (через ограничения в моделях),
- кастомная (валидаторы).

Это даёт:
- безопасность,
- удобство (меньше ручных проверок),
- автогенерацию документации.