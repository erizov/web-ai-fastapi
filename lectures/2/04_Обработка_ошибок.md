# Обработка ошибок в FastAPI

## Введение

Ошибки — нормальная часть работы API.  
Задача разработчика: не скрыть ошибку, а вернуть её в понятном формате.

### В FastAPI:
- часть ошибок обрабатывается автоматически (422, 404),
- часть нужно обрабатывать вручную (например, 400, 403, 500).

## Автоматические ошибки (422, 404)

`Ошибка 422` — Unprocessable Entity  

Возникает при валидации запроса.

Пример:  
```
from fastapi import FastAPI

app = FastAPI()

@app.get("/items/{item_id}")
def read_item(item_id: int):
    return {"item_id": item_id}

Запрос: /items/abc  
Ответ: 422

{
  "detail": [
    {
      "loc": ["path", "item_id"],
      "msg": "value is not a valid integer",
      "type": "type_error.integer"
    }
  ]
}
```

`Ошибка 404` — Not Found

Возникает, если путь не существует.
```
GET /wrong-url
→ 404 {"detail": "Путь не существует"}
```

FastAPI сам возвращает стандартный JSON.

## Явные ошибки (HTTPException)

Чтобы бросить ошибку вручную, используем HTTPException.
```
from fastapi import HTTPException

@app.get("/users/{user_id}")
def get_user(user_id: int):
    if user_id != 1:
        raise HTTPException(status_code=404, detail="Пользователь не найден")
    return {"id": 1, "name": "Алиса"}
```

Полезные параметры:
- status_code — код ошибки (400, 403, 500 …).  
- detail — описание ошибки.  
- headers — можно вернуть кастомные заголовки (например, WWW-Authenticate).  

Пример для 400 (Bad Request):

```
@app.post("/calc")
def calc(x: int, y: int):
    if y == 0:
        raise HTTPException(status_code=400, detail="Division by zero")
    return {"result": x / y}
```

## Глобальные обработчики ошибок

FastAPI позволяет регистрировать кастомный обработчик для любой ошибки.

```
from fastapi.responses import JSONResponse
from fastapi.requests import Request

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content={"error": exc.detail, "status": exc.status_code},
    )
```

Теперь все ошибки будут в едином формате:  
```
{"error": "User not found", "status": 404}
```

Обработка конкретных ошибок

Например, ловим только ValueError:
```
@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError):
    return JSONResponse(
        status_code=400,
        content={"error": str(exc)},
    )
```

## Кастомные модели ошибок

Мы можем заранее описать схему ответа для ошибок.

```
from pydantic import BaseModel

class ErrorResponse(BaseModel):
    error: str
    code: int

@app.get("/fail", responses={400: {"model": ErrorResponse}})
def fail_example():
    raise HTTPException(status_code=400, detail="Bad input")
```

→ В Swagger будет видно, что в случае 400 возвращается объект {error, code}.

## Обработка ошибок на уровне зависимостей

Если проверяем авторизацию или токен — удобно кидать ошибку прямо там.

```
from fastapi import Depends

def check_token(token: str):
    if token != "secret":
        raise HTTPException(status_code=403, detail="Invalid token")

@app.get("/secure")
def secure_data(dep=Depends(check_token)):
    return {"data": "secret info"}
```

## Заключение

FastAPI автоматически обрабатывает:
- 422 (валидация),  
- 404 (нет маршрута).  

Мы сами можем бросать ошибки через HTTPException.  
Для единообразия → используем глобальные обработчики.  
Для документации → описываем responses={...}.  
Результат: предсказуемый и красивый API.